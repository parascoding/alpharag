import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from datetime import datetime
from typing import Dict, List, Optional, Union
import logging

logger = logging.getLogger(__name__)

class EmailService:
    def __init__(self, smtp_server: str, smtp_port: int, username: str, password: str):
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.username = username
        self.password = password

    def send_portfolio_analysis(self, to_emails: Union[str, List[str]], portfolio_data: Dict,
                               market_data: Dict, sentiment_data: Dict,
                               predictions: Dict, financial_data: Optional[Dict] = None) -> bool:
        try:
            # Convert single email to list for consistency
            if isinstance(to_emails, str):
                to_emails = [to_emails]

            subject = f"AlphaRAG Portfolio Analysis - {datetime.now().strftime('%Y-%m-%d %H:%M')}"

            # Create email content
            email_body = self._create_analysis_email(portfolio_data, market_data,
                                                   sentiment_data, predictions, financial_data)

            # Send email to all recipients
            success_count = 0
            for email in to_emails:
                if self._send_email(email.strip(), subject, email_body):
                    success_count += 1
                    logger.info(f"Portfolio analysis email sent successfully to {email}")
                else:
                    logger.error(f"Failed to send email to {email}")

            # Consider successful if sent to at least one recipient
            success = success_count > 0

            if success:
                logger.info(f"Portfolio analysis sent to {success_count}/{len(to_emails)} recipients")

            return success

        except Exception as e:
            logger.error(f"Error sending portfolio analysis email: {e}")
            return False

    def _create_analysis_email(self, portfolio_data: Dict, market_data: Dict,
                              sentiment_data: Dict, predictions: Dict,
                              financial_data: Optional[Dict] = None) -> str:

        # Get current timestamp
        timestamp = datetime.now().strftime('%B %d, %Y at %I:%M %p')

        # Build email content
        email_parts = [
            "ðŸŽ¯ AlphaRAG Portfolio Analysis Report",
            "=" * 50,
            f"Generated on: {timestamp}",
            "",
            "ðŸ“Š PORTFOLIO SUMMARY",
            "-" * 25,
            self._format_portfolio_summary(portfolio_data),
            "",
            "ðŸ“ˆ MARKET DATA",
            "-" * 15,
            self._format_market_summary(market_data),
            "",
            "ðŸ“° SENTIMENT ANALYSIS",
            "-" * 22,
            self._format_sentiment_summary(sentiment_data),
            "",
            "ðŸ’° FINANCIAL HEALTH SCORECARD" if financial_data else "",
            "-" * 33 if financial_data else "",
            self._format_financial_scorecard(financial_data) if financial_data else "",
            "" if financial_data else "",
            "ðŸŽ¯ INVESTMENT RECOMMENDATIONS",
            "-" * 31,
            self._format_predictions(predictions),
            "",
            "âš ï¸  RISK DISCLAIMER",
            "-" * 18,
            "This analysis is generated by AI and should not be considered as financial advice.",
            "Always consult with a qualified financial advisor before making investment decisions.",
            "Past performance does not guarantee future results.",
            "",
            "---",
            "Generated by AlphaRAG - AI-Powered Portfolio Analysis",
            f"Report ID: {hash(str(portfolio_data) + str(predictions)) % 100000}"
        ]

        return "\n".join(email_parts)

    def _format_portfolio_summary(self, portfolio_data: Dict) -> str:
        summary = portfolio_data['summary']
        holdings = portfolio_data['holdings']

        lines = [
            f"ðŸ’° Total Investment: â‚¹{summary['total_investment']:,.2f}",
            f"ðŸ’Ž Current Value: â‚¹{summary['total_current_value']:,.2f}",
            f"ðŸ“Š Total P&L: â‚¹{summary['total_pnl']:,.2f} ({summary['total_pnl_percent']:+.2f}%)",
            ""
        ]

        # Performance indicator
        pnl_percent = summary['total_pnl_percent']
        if pnl_percent > 5:
            lines.append("ðŸš€ Portfolio Status: Strong Performance")
        elif pnl_percent > 0:
            lines.append("ðŸ“ˆ Portfolio Status: Positive Performance")
        elif pnl_percent > -5:
            lines.append("ðŸ“Š Portfolio Status: Stable")
        else:
            lines.append("ðŸ“‰ Portfolio Status: Needs Attention")

        lines.extend(["", "Individual Holdings:"])

        for holding in holdings:
            pnl_emoji = "ðŸŸ¢" if holding['pnl_percent'] > 0 else "ðŸ”´" if holding['pnl_percent'] < 0 else "âšª"
            lines.append(
                f"{pnl_emoji} {holding['symbol']}: {holding['quantity']} shares "
                f"(Buy: â‚¹{holding['buy_price']:.2f}, Current: â‚¹{holding['current_price']:.2f}, "
                f"P&L: {holding['pnl_percent']:+.2f}%)"
            )

        return "\n".join(lines)

    def _format_market_summary(self, market_data: Dict) -> str:
        market_status = market_data.get('market_status', 'Unknown')
        status_emoji = "ðŸŸ¢" if market_status == 'open' else "ðŸ”´"

        lines = [
            f"{status_emoji} Market Status: {market_status.title()}",
            "",
            "Current Stock Prices:"
        ]

        prices = market_data.get('prices', {})
        for symbol, price in prices.items():
            lines.append(f"  â€¢ {symbol}: â‚¹{price:.2f}")

            # Add technical analysis if available
            tech_key = f"{symbol}_technical"
            if tech_key in market_data:
                tech = market_data[tech_key]
                rsi = tech.get('rsi')
                if rsi:
                    if rsi > 70:
                        lines.append(f"    ðŸ“Š RSI: {rsi:.1f} (Overbought)")
                    elif rsi < 30:
                        lines.append(f"    ðŸ“Š RSI: {rsi:.1f} (Oversold)")
                    else:
                        lines.append(f"    ðŸ“Š RSI: {rsi:.1f} (Normal)")

        return "\n".join(lines)

    def _format_sentiment_summary(self, sentiment_data: Dict) -> str:
        overall = sentiment_data['overall_sentiment']

        sentiment_emoji = {
            'positive': 'ðŸ˜Š',
            'negative': 'ðŸ˜Ÿ',
            'neutral': 'ðŸ˜'
        }.get(overall['label'], 'â“')

        lines = [
            f"{sentiment_emoji} Overall Market Sentiment: {overall['label'].title()} "
            f"(Score: {overall['score']:+.3f})",
            f"ðŸ“„ Total Articles Analyzed: {sentiment_data['total_articles']}",
            "",
            "Individual Stock Sentiment:"
        ]

        for symbol, data in sentiment_data['individual_sentiment'].items():
            sentiment_emoji = {
                'positive': 'ðŸ˜Š',
                'negative': 'ðŸ˜Ÿ',
                'neutral': 'ðŸ˜'
            }.get(data['sentiment_label'], 'â“')

            lines.append(
                f"  {sentiment_emoji} {symbol}: {data['sentiment_label'].title()} "
                f"(Score: {data['sentiment_score']:+.3f}, Articles: {data['article_count']})"
            )

            # Add news article links if available
            articles = data.get('articles', [])
            if articles:
                lines.append("     ðŸ“° Related News:")
                for i, article in enumerate(articles[:3], 1):  # Show top 3 articles
                    title = article.get('title', 'Untitled')
                    # Check for both 'url' and 'link' fields (different providers use different fields)
                    article_url = article.get('url') or article.get('link')
                    
                    if article_url:
                        lines.append(f"       {i}. {title}")
                        lines.append(f"          ðŸ”— {article_url}")
                    else:
                        lines.append(f"       {i}. {title} (No link available)")
                lines.append("")  # Empty line after articles

        return "\n".join(lines)

    def _format_financial_scorecard(self, financial_data: Optional[Dict]) -> str:
        """Format financial health scorecard for email"""
        if not financial_data:
            return "Financial indicators not available."

        lines = []

        for symbol, data in financial_data.items():
            health_score = data.get('health_score', {})
            overall_score = health_score.get('overall_score', 0)
            rating = health_score.get('rating', 'Unknown')
            rating_emoji = health_score.get('rating_emoji', 'â“')

            lines.extend([
                f"{rating_emoji} {symbol} ({data.get('sector', 'Unknown')} Sector):",
                f"   Overall Score: {overall_score:.1f}/10 ({rating})",
                f"   Market Cap: â‚¹{data.get('market_cap_cr', 0):,.0f} crores",
                ""
            ])

            # Key financial metrics in a compact format
            lines.extend([
                "   ðŸ“Š Key Ratios:",
                f"      P/E: {data.get('pe_ratio', 0):.1f}x, P/B: {data.get('pb_ratio', 0):.1f}x, ROE: {data.get('roe', 0):.1f}%",
                f"      Debt/Equity: {data.get('debt_to_equity', 0):.2f}, Current Ratio: {data.get('current_ratio', 0):.2f}",
                f"      Net Margin: {data.get('net_profit_margin', 0):.1f}%, Revenue Growth: {data.get('revenue_growth_yoy', 0):+.1f}%",
                ""
            ])

            # Score breakdown
            lines.extend([
                "   ðŸŽ¯ Score Breakdown:",
                f"      Valuation: {health_score.get('valuation_score', 0):.1f}/10",
                f"      Profitability: {health_score.get('profitability_score', 0):.1f}/10",
                f"      Financial Health: {health_score.get('financial_health_score', 0):.1f}/10",
                f"      Growth: {health_score.get('growth_score', 0):.1f}/10",
                ""
            ])

            # Risk assessment
            debt_equity = data.get('debt_to_equity', 0)
            current_ratio = data.get('current_ratio', 0)

            risk_factors = []
            if debt_equity > 0.8:
                risk_factors.append("High debt")
            if current_ratio < 1.0:
                risk_factors.append("Liquidity concern")
            if data.get('roe', 0) < 10:
                risk_factors.append("Low profitability")

            if risk_factors:
                lines.extend([
                    f"   âš ï¸  Risk Factors: {', '.join(risk_factors)}",
                    ""
                ])
            else:
                lines.extend([
                    "   âœ… No major risk factors identified",
                    ""
                ])

        return "\n".join(lines)

    def _format_predictions(self, predictions: Dict) -> str:
        lines = []

        # Emergency fallback notification
        if predictions.get('emergency_fallback'):
            lines.extend([
                "âš ï¸  Note: Using emergency rule-based analysis due to AI service unavailability",
                ""
            ])
        elif predictions.get('fallback_mode'):
            lines.extend([
                "âš ï¸  Note: Using simplified analysis due to API limitations",
                ""
            ])

        # Individual recommendations
        logger.info(predictions)
        recommendations = predictions.get('individual_recommendations', {})
        if recommendations:
            lines.extend(["ðŸ“ˆ Individual Stock Recommendations:", ""])

            # Sort by recommendation for better readability
            sorted_recs = sorted(recommendations.items(), key=lambda x: {'BUY': 0, 'HOLD': 1, 'SELL': 2}.get(x[1]['recommendation'], 3))

            for symbol, rec in sorted_recs:
                rec_emoji = {
                    'BUY': 'ðŸŸ¢',
                    'SELL': 'ðŸ”´',
                    'HOLD': 'ðŸŸ¡'
                }.get(rec['recommendation'], 'â“')

                confidence_stars = 'â­' * min(rec.get('confidence', 5), 5)

                lines.append(
                    f"{rec_emoji} {symbol}: {rec['recommendation']} "
                    f"(Confidence: {confidence_stars})"
                )

                if 'reasoning' in rec and rec['reasoning']:
                    # Include full reasoning without truncation
                    reasoning = rec['reasoning']
                    lines.append(f"   ðŸ“ {reasoning}")

                lines.append("")

            lines.extend([
                f"ðŸ“Š Total Recommendations: {len(recommendations)} stocks analyzed",
                ""
            ])

        else:
            lines.extend([
                "âŒ No individual stock recommendations available",
                "   Please check system logs for details",
                ""
            ])

        # New stock purchase recommendations
        new_recommendations = predictions.get('new_stock_recommendations', {})
        available_cash = predictions.get('available_cash', 0)
        
        if new_recommendations and available_cash > 0:
            lines.extend(["ðŸ’° New Stock Purchase Recommendations:", ""])
            lines.append(f"Available Cash: â‚¹{available_cash:,.2f}")
            lines.append("")
            
            total_suggested = 0
            for symbol, rec in new_recommendations.items():
                # Only include valid new stock recommendations (must have recommended_amount or current_price)
                if not rec.get('recommended_amount') and not rec.get('current_price'):
                    continue
                    
                # Handle both field name variations
                suggested_amount = float(rec.get('recommended_amount', rec.get('suggested_amount', 0)))
                if suggested_amount == 0:
                    continue  # Skip entries without investment amount
                    
                current_price = rec.get('current_price', 'N/A')
                target_price = rec.get('target_price', 'N/A')
                sector = rec.get('sector', 'Unknown')
                confidence = rec.get('confidence', 5)
                rationale = rec.get('investment_thesis', rec.get('investment_rationale', 'No rationale provided'))
                risk_level = rec.get('risk_level', 'MEDIUM')
                
                confidence_stars = 'â­' * min(confidence, 5)
                
                lines.extend([
                    f"ðŸ”¥ {symbol} ({sector})",
                    f"   ðŸ’° Suggested Investment: â‚¹{suggested_amount:,.0f}",
                    f"   ðŸ’¹ Current Price: â‚¹{current_price}  |  ðŸŽ¯ Target: â‚¹{target_price}",
                    f"   ðŸ“Š Risk Level: {risk_level}  |  â­ Confidence: {confidence_stars} ({confidence}/10)",
                    f"   ðŸ“ Investment Thesis: {rationale}",
                    ""
                ])
                
                total_suggested += suggested_amount
            
            remaining_cash = available_cash - total_suggested
            lines.extend([
                f"ðŸ’¡ Total Suggested Investment: â‚¹{total_suggested:,.2f}",
                f"ðŸ’µ Remaining Cash: â‚¹{remaining_cash:,.2f}",
                "",
                "Note: These are AI-generated suggestions. Please conduct your own research before investing.",
                ""
            ])
            
        elif available_cash > 1000:
            lines.extend([
                "ðŸ’° Available Cash for Investment:",
                f"   Cash Available: â‚¹{available_cash:,.2f}",
                "   âš ï¸ No new stock recommendations generated",
                "   Consider manual research for new investment opportunities",
                ""
            ])

        # Portfolio analysis
        if predictions.get('portfolio_analysis'):
            lines.extend([
                "ðŸŽ¯ Portfolio Overview:",
                predictions['portfolio_analysis'],
                ""
            ])

        # Action items
        action_items = predictions.get('action_items', [])
        if action_items:
            lines.extend(["ðŸ“‹ Recommended Actions:", ""])
            for i, item in enumerate(action_items, 1):
                lines.append(f"  {i}. {item}")
            lines.append("")

        # Market insights
        if predictions.get('market_insights'):
            lines.extend([
                "ðŸ” Market Insights:",
                predictions['market_insights'],
                ""
            ])

        # Add generation metadata for debugging
        if predictions.get('provider_used'):
            lines.extend([
                f"ðŸ¤– Analysis Provider: {predictions['provider_used'].upper()}",
                f"â° Generated: {predictions.get('timestamp', 'Unknown')}",
                ""
            ])

        return "\n".join(lines)

    def _send_email(self, to_email: str, subject: str, body: str) -> bool:
        try:
            # Log email size for debugging
            body_size = len(body.encode('utf-8'))
            logger.info(f"ðŸ“§ Email size: {body_size:,} bytes ({body_size/1024:.1f} KB)")

            # Create message
            msg = MIMEMultipart()
            msg['From'] = self.username
            msg['To'] = to_email
            msg['Subject'] = subject

            # Add body to email with explicit encoding
            msg.attach(MIMEText(body, 'plain', 'utf-8'))

            # Create SMTP session with debugging
            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            server.starttls()  # Enable TLS encryption
            server.login(self.username, self.password)

            # Send email
            text = msg.as_string()
            logger.info(f"ðŸ“§ Total message size: {len(text):,} bytes")
            
            server.sendmail(self.username, to_email, text)
            server.quit()

            logger.info(f"ðŸ“§ Email sent successfully to {to_email}")
            return True

        except Exception as e:
            logger.error(f"SMTP error: {e}")
            return False

    def send_test_email(self, to_emails: Union[str, List[str]]) -> bool:
        """Send a test email to verify configuration"""
        try:
            # Convert single email to list for consistency
            if isinstance(to_emails, str):
                to_emails = [to_emails]

            subject = "AlphaRAG Test Email"
            body = f"""
Hello!

This is a test email from AlphaRAG to verify your email configuration.

If you received this email, your SMTP settings are working correctly.

Timestamp: {datetime.now().isoformat()}

Recipient list: {', '.join(to_emails)}

Best regards,
AlphaRAG System
            """.strip()

            # Send test email to all recipients
            success_count = 0
            for email in to_emails:
                if self._send_email(email.strip(), subject, body):
                    success_count += 1
                    logger.info(f"Test email sent successfully to {email}")
                else:
                    logger.error(f"Failed to send test email to {email}")

            # Consider successful if sent to at least one recipient
            success = success_count > 0

            if success:
                logger.info(f"Test email sent to {success_count}/{len(to_emails)} recipients")

            return success

        except Exception as e:
            logger.error(f"Error sending test email: {e}")
            return False